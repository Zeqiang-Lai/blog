<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Ze&#39;s Blog</title>
    <link>https://zeqiang-lai.github.io/blog/</link>
    <description>Recent content in Introduction on Ze&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://zeqiang-lai.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>More about Variational Autoencoder</title>
      <link>https://zeqiang-lai.github.io/blog/posts/deep-learning/vae-more/</link>
      <pubDate>Fri, 04 Dec 2020 21:32:04 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/deep-learning/vae-more/</guid>
      <description>&lt;p&gt;一些关于VAE的扩展知识。&lt;/p&gt;
&lt;p&gt;不断更新中&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hugo-Book Shortcodes Usages</title>
      <link>https://zeqiang-lai.github.io/blog/posts/misc/hugo-book/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/misc/hugo-book/</guid>
      <description>&lt;p&gt;Hugo-Book Shortcodes Usages&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Semaphores(信号量)</title>
      <link>https://zeqiang-lai.github.io/blog/posts/programming/semaphores/</link>
      <pubDate>Tue, 16 Oct 2018 13:52:51 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/programming/semaphores/</guid>
      <description>&lt;p&gt;Semaphores是一种同步机制（Concurrency Mechanisms），它用来协调各个进程访问公共资源。其基本思想如下所述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个或多个进程通过一个信号量进行协调，当一个进程需要某个资源时，它需要申请并等待一个信号，如果信号没有来临则等待。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>错误检测-海(汉)明码</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/%E6%B5%B7%E6%98%8E%E7%A0%81/</link>
      <pubDate>Mon, 15 Oct 2018 17:08:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/%E6%B5%B7%E6%98%8E%E7%A0%81/</guid>
      <description>&lt;p&gt;Hamming code，海明码，汉明码都是一个东西。它是一种编码方式，通常用在网络信息传输中，通过这种编码方式编码出来的二进制数据具有检测一位错误位的能力。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>How genralized linear model work?</title>
      <link>https://zeqiang-lai.github.io/blog/posts/machine-learning/Generalized-Linear-Model/</link>
      <pubDate>Sat, 12 May 2018 08:24:04 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/machine-learning/Generalized-Linear-Model/</guid>
      <description>&lt;p&gt;本文将简单的讲述：GLM是如何工作的？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>克鲁斯卡尔算法</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 15 Apr 2018 14:03:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;首先，克鲁斯卡尔算法是用来求最小生成树的。另一种求最小生成树的算法叫普林姆算法（Prim）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>普林姆算法</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 15 Apr 2018 14:03:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;普林姆算法也是用来求最小生成树的，与克鲁斯卡尔算法遍历边不同，普林姆遍历的是点。&lt;/p&gt;
&lt;p&gt;普林姆算法同样基于贪心，以任意点为初始点，每次选取&lt;code&gt;与已选点相连的边&lt;/code&gt;中&lt;code&gt;权值最小&lt;/code&gt;的边，并把与这条边相连的点加入已选点集合。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Sun, 15 Apr 2018 12:03:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>&lt;p&gt;使用并查集可以快速判断两个元素是否属于同一个集合。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Principal component analysis</title>
      <link>https://zeqiang-lai.github.io/blog/posts/machine-learning/Principal-component-analysis/</link>
      <pubDate>Mon, 08 Jan 2018 12:45:04 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/machine-learning/Principal-component-analysis/</guid>
      <description>&lt;p&gt;PCA (Principal component analysis) 是一种给数据降维的方法。&lt;/p&gt;
&lt;p&gt;利用PCA，能将一堆高维空间的数据映射到一个低维空间，并最大限度保持它们之间的可区分性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>洛伦兹变换</title>
      <link>https://zeqiang-lai.github.io/blog/posts/misc/%E6%B4%9B%E4%BC%A6%E5%85%B9%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Sun, 17 Dec 2017 21:33:22 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/misc/%E6%B4%9B%E4%BC%A6%E5%85%B9%E5%8F%98%E6%8D%A2/</guid>
      <description>&lt;p&gt;洛伦兹变换是从光速不变原理推出的，不同坐标系坐标之间的转换关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fibonacci数的迭代算法</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/Fibonacci%E6%95%B0%E7%9A%84%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 30 Sep 2017 16:01:39 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/Fibonacci%E6%95%B0%E7%9A%84%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;使用迭代算法求斐波那契数列，&lt;/p&gt;
&lt;p&gt;时间复杂度O(n)，空间复杂度O(1)。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>快速幂算法</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sat, 30 Sep 2017 15:25:28 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>&lt;p&gt;在c，c++语言中，并没有提供求幂的基本运算，通常我们需要自己写函数或者调用STL提供的函数。&lt;/p&gt;
&lt;p&gt;一般情况下，我们写的求幂函数基本上都是循环累乘，时间复杂度为O(n)。虽说是线性的时间复杂度，但求幂运算作为基础运算，往往调用频繁，这时候即使是线性的时间复杂度也将变得难也接受。&lt;/p&gt;
&lt;p&gt;利用快速幂可以快速计算底数的n次幂。其时间复杂度为 O(logn)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>位运算的妙用</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/</link>
      <pubDate>Wed, 27 Sep 2017 13:52:51 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8/</guid>
      <description>&lt;p&gt;对于一些特定问题，巧妙运用位运算能使解法异常&lt;strong&gt;简洁&lt;/strong&gt;和&lt;strong&gt;高效&lt;/strong&gt;，同时，适当运用位运算也能对程序进行&lt;strong&gt;优化&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>筛法求素数</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0/</link>
      <pubDate>Fri, 15 Sep 2017 21:33:22 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;假设要求n以内的素数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;筛法求素数是用一个大小为n的数组，作为标记数组，如果没被标记到则为素数。&lt;/p&gt;
&lt;p&gt;开始均为未标记。&lt;/p&gt;
&lt;p&gt;从2开始，2没被标记，将2存入一个存素数的地方，然后筛掉小于n的，2的所有倍数。然后是3，筛掉3的所有倍数，依此类推，直到n-1。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>各种矩阵</title>
      <link>https://zeqiang-lai.github.io/blog/docs/matrix/types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/docs/matrix/types/</guid>
      <description>Created: Decemenber, 1, 2020 对称矩阵 #    定义：满足$A^T=A$的矩阵。 显然，对称矩阵是方阵，否则转一下形状都变了。  实对称矩阵的特征值都是实数 证明：
已知$Ax = \lambda x$，左右两边同时取共轭，有
$$ \bar{A}\bar{x}=\bar{\lambda}\bar{x} $$
因为A是实对称矩阵，$\bar{A}=A$，因此有 $$ A\bar{x}=\bar{\lambda}\bar{x} $$
左右两边同时取转置，有
$$ \bar{x}^TA=\bar{x}^T\bar{\lambda} $$
左右两边同时右乘x，得 $$ \bar{x}^TAx=\bar{x}^T\bar{\lambda}x $$
对$Ax = \lambda x$，左右两边同时左乘$\bar{x}^T$，得 $$ \bar{x}^TAx=\bar{x}^T\lambda x $$
比较两个式子，可以得到
$$ \bar{\lambda} = \lambda $$
一个数的共轭等于其本身，这个数是实数。
  对称矩阵的特征向量是正交的。   正定矩阵 #   正定矩阵是对称矩阵的一种特殊情况，因此它也是对称的。
定义 #  正定矩阵有各种各样的定义，它们互相之间是等价的。下面是几种常见定义/判定方法：
 所有特征值大于0。 所有顺序主子式都大于0。 所有Pivots都大于0。 $x^TAx&amp;gt;0$ ： $x=[x_1,x_2, &amp;hellip;, x_n]$, 对于所有的x恒大于0  类似的可以定义半正定(大于等于0)，负定（小于0），半负定（小于等于0）。</description>
    </item>
    
    <item>
      <title>奇异值分解</title>
      <link>https://zeqiang-lai.github.io/blog/docs/matrix/svd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/docs/matrix/svd/</guid>
      <description>&lt;h5&gt;Created: Decemenber, 1, 2020&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;所有矩阵&lt;/strong&gt;都可以分解成：&lt;strong&gt;正交矩阵 * 对角矩阵 * 正交矩阵&lt;/strong&gt;，这个分解叫&lt;strong&gt;奇异值分解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;$$
A = U\Sigma V^T
$$&lt;/p&gt;
&lt;p&gt;其中A是一个m*n的矩阵，V是一个n*n的矩阵，U是一个m*m的矩阵，$\Sigma$是一个m*n的矩阵。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何将各个知识点串起来？</title>
      <link>https://zeqiang-lai.github.io/blog/docs/matrix/road/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/docs/matrix/road/</guid>
      <description>Created: Decemenber, 3, 2020 引入 特征值与特征向量之后，我们可以很容易的推导出 矩阵对角化的公式。
矩阵对角化是针对一般方阵的，对于特殊方阵，如 对称矩阵，矩阵对角化可以进一步特化。
对称矩阵有很多很好的性质，它是它的进一步特例， 正定矩阵有着更好的性质。
#  </description>
    </item>
    
    <item>
      <title>杂七杂八</title>
      <link>https://zeqiang-lai.github.io/blog/docs/matrix/misc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/docs/matrix/misc/</guid>
      <description>Created: Decemenber, 1, 2020 Spectrum(谱) #  矩阵中有谱（spectrum）这个概念，例如谱分解，谱范数等等。
这个谱其实说的就是特征值，特征向量，它是从光学里借过来的说法。光学中光是由各种pure light构成的，光谱就是各个成分的占比。而在矩阵中，矩阵由各个pure的component，特征值特征向量构成。
进一步来说，我们看矩阵对角化，我们知道任何一个对称矩阵A都可以对角化成$Q\Lambda Q^{T}$，其中Q为特征向量组成的矩阵。
我们进一步把这个式子拆开，我们设A的特征向量为$q_i$, 则
$$ A = Q\Lambda Q^{T} = \lambda_1 q_1 q_1^T + \lambda_2 q_2 q_2^T + &amp;hellip; + \lambda_n q_n q_n^T $$
$q_i$是一个列向量，$q_1 q_1^T$是一个矩阵，因此A实际上就化成了n个矩阵的线性组合，第i个矩阵是$q_i q_i^T$，系数是特征值$\lambda_i$。</description>
    </item>
    
    <item>
      <title>特征值&amp;&amp;特征向量</title>
      <link>https://zeqiang-lai.github.io/blog/docs/matrix/eigen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/docs/matrix/eigen/</guid>
      <description>Created: Decemenber, 1, 2020 首先明确一点，特征值和特征向量是针对方阵来说的，我们说某个矩阵A有什么特征值和特征向量时，我们实际上暗示了矩阵A是一个方阵。
定义 #  任何满足下列条件的标量和向量分别为矩阵A的特征值和特征向量。1
$$ Ax = \lambda x $$
Intuition #  将一个矩阵A与一个向量x相乘，我们实际上在对向量x做一个 线性变换，特征向量实际上就是经过这个变换与原向量仍然平行的那些向量，特征值就是前后两个向量长度的一个比值。
 显然，零向量满足条件，那它是任何矩阵的特征向量吗？
不是，我们显示将特征向量定义为非零向量。
 求解 #  根据定义，有
$$ (A-\lambda I)x = 0 $$
这个等式要有非零解，$(A-\lambda I)$必须是singular（不可逆）的，特征值要等于0：
$$ Det(A-\lambda I) = 0 $$
于是：
 求行列式并解方程即可求出特征值。 对于特征向量，我们回代特征值，解$(A-\lambda I)x=0$这个方程。  因为$(A-\lambda I)$不可逆，所以解有无穷多个，即特征向量有无穷多个，这时候我们只需要给出一个就行了。    性质 #   $\sum \lambda = trace(A)$ : 矩阵A的所有特征值之和等于矩阵A的 trace（对角线元素之和）。 $\prod \lambda = det(A)$ : 矩阵A的所有特征值的乘积等于矩阵A的行列式。 三角矩阵的特征值就是对角线上的元素。 对称矩阵的特征向量是正交的。  证明：对称矩阵的特征向量是正交的 To be done     由特征向量的定义，显然A必须要个方阵，若不是，A与x相乘，x维数就变了。 &amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>矩阵对角化</title>
      <link>https://zeqiang-lai.github.io/blog/docs/matrix/diagonalization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/docs/matrix/diagonalization/</guid>
      <description>Created: Decemenber, 1, 2020  To be continue.  Keypoint: 一些矩阵可以对角化 $S^{-1}AS = \Lambda$。其中S为特征向量(列向量)构成的矩阵，$\Lambda$为特征值构成的对角矩阵。
 什么样的矩阵可以？ 因为定义里S要可逆，所以A必须拥有n个线性无关的特征向量。   关于矩阵对角化，我们其实可以从两个角度理解：
 一些矩阵可以对角化$S^{-1}AS = \Lambda$。 或一些矩阵可以化成三个矩阵的乘积：$A = S\Lambda S^{-1}$  推导 #   $$ \begin{equation} \begin{aligned} AS &amp;= A[x_1, x_2, ..., x_n] = [Ax_1, Ax_2, ..., Ax_n] = [\lambda_1 x_1, \lambda_1 x_2, ..., \lambda_1 x_n] \\\\\\ &amp;= [x_1, x_2, ..., x_n] \begin{bmatrix} \lambda_1 &amp; 0 &amp; \cdots &amp; 0\\ 0 &amp; \lambda_2 &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \lambda_n\\ \end{bmatrix} = S\Lambda \end{aligned} \end{equation} $$  左右两边同时乘S的逆，即可得到：</description>
    </item>
    
    <item>
      <title>贪心生成最优编码的思路分析</title>
      <link>https://zeqiang-lai.github.io/blog/posts/algorithms/%E8%B4%AA%E5%BF%83%E7%94%9F%E6%88%90%E6%9C%80%E4%BC%98%E7%BC%96%E7%A0%81%E7%9A%84%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zeqiang-lai.github.io/blog/posts/algorithms/%E8%B4%AA%E5%BF%83%E7%94%9F%E6%88%90%E6%9C%80%E4%BC%98%E7%BC%96%E7%A0%81%E7%9A%84%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;贪心生成最优编码的思路分析&#34;&gt;
  贪心生成最优编码的思路分析
  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%aa%e5%bf%83%e7%94%9f%e6%88%90%e6%9c%80%e4%bc%98%e7%bc%96%e7%a0%81%e7%9a%84%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：求字符编码&lt;/p&gt;
&lt;p&gt;首先得先想到用二叉树表示编码，节点即为字符，边为编码。&lt;/p&gt;
&lt;p&gt;然后优化目标（目标函数）即为： &lt;code&gt;f(x) = w(x)*l(x)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;w(x) 为 字符x的频率&lt;/li&gt;
&lt;li&gt;l(x) 为 字符编码的长度&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
